<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Powershell on Notebook</title><link>https://dpurge.github.io/docs/programming/powershell/</link><description>Recent content in Powershell on Notebook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dpurge.github.io/docs/programming/powershell/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://dpurge.github.io/docs/programming/powershell/basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dpurge.github.io/docs/programming/powershell/basics/</guid><description> Powershell basics #</description></item><item><title/><link>https://dpurge.github.io/docs/programming/powershell/snippets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dpurge.github.io/docs/programming/powershell/snippets/</guid><description>Powershell snippets # Get unix timestamp # [int](Get-Date -UFormat %s -Millisecond 0) Match glob pattern # function Test-GlobMatch { param ( [string] $value, [string] $pattern ) $position = 0 foreach ($char in $pattern.toCharArray()) { Switch ($char) { &amp;#39;?&amp;#39; { continue } &amp;#39;*&amp;#39; { foreach ($i in $value.Length .. $position) { if (Test-GlobMatch $value.Substring($i) $pattern.Substring($position + 1)) { return $True } } return $False } default { if ($value.Length -eq $position -or $pattern[$position] -ne $value[$position]) { return $False } } } $position++ } return $value.</description></item></channel></rss>